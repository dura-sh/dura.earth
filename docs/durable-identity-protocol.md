---
order: 5
title: Durable Identity Protocol
type: Concept Model & Protocols Specs
---

## A Securty Protocol for Covergence of Cryptographic Premitive Sequences

The Durable Identity Protocol details a functional approach to digitially represent an inidivuals intretation of being sure or certain of reality by performing sequences of cryptographic prematives reflective of their sensativity to background knoweledge, relational trees, and situational perceptions while determining how sure they are of another human applicable to certain engagement, keeping a unique record of the results for reference. Over a nominal time period with a cirtical mass of records, a chartable maxtrix meshed patterns converge in-such a way that unique record ownership can be proven without any agreed upon public or centralized reference point. Providing a durable software solution proof of identity in a distributed fashion without realying on a federation.

## Surety

> A durablility-driven cryptographic premitives sequencing that implements the [double cryptographic ratchet](https://whispersystems.org/docs/specifications/doubleratchet/) where identification is certain prior to a message exchanges.

### Setup

#### Notation

This document uses \$`\parallel`$ to represent string concatenation. When $`\parallel`$ appears on the right hand side of an $`=`$ it means that
the inputs are concatenated. When $`\parallel`$ appears on the left hand
side of an $`=`\$ it means that the output is split.

When this document uses \$`ECDH\left(K_A,\,K_B\right)`$ it means that each
party computes a Diffie-Hellman agreement using their private key and the
remote party's public key.
So party $`A`$ computes $`ECDH\left(K_B^{public},\,K_A^{private}\right)`$
and party $`B`$ computes $`ECDH\left(K_A^{public},\,K_B^{private}\right)`\$.

Where this document uses \$`HKDF\left(salt,\,IKM,\,info,\,L\right)`$ it
refers to the [HMAC-based key derivation function][] with a salt value of
$`salt`$, input key material of $`IKM`$, context string $`info`$,
and output keying material length of $`L`\$ bytes.

The setup takes four [Curve25519][] inputs: Identity keys for Dochughes and Whimzyy, \$`I_A`$ and $`I_B`$, and one-time keys for Dochughes and Whimzyy,
$`E_A`$ and $`E_B`$. A shared secret, $`S`$, is generated using
[Triple Diffie-Hellman][]. The initial 256 bit root key, $`R_0`$, and 256
bit chain key, $`C_{0,0}`\$, are derived from the shared secret using an HMAC-based Key Derivation Function using [SHA-256][] as the hash function ([HKDF-SHA-256][]) with default salt and `"SURETY_ROOT"` as the info.

```math
\begin{aligned}
    S&=ECDH\left(I_A,\,E_B\right)\;\parallel\;ECDH\left(E_A,\,I_B\right)\;
        \parallel\;ECDH\left(E_A,\,E_B\right)\\
    R_0\;\parallel\;C_{0,0}&=
            HKDF\left(0,\,S,\,\text{"SURETY\_ROOT"},\,64\right)
\end{aligned}
```

### Advancing the root key

Advancing a root key takes the previous root key, \$`R_{i-1}`$, and two
Curve25519 inputs: the previous ratchet key, $`T_{i-1}`$, and the current
ratchet key $`T_i`$. The even ratchet keys are generated by Dochughes.
The odd ratchet keys are generated by Whimzyy. A shared secret is generated
using Diffie-Hellman on the ratchet keys. The next root key, $`R_i`$, and
chain key, $`C_{i,0}`$, are derived from the shared secret using
[HKDF-SHA-256][] using $`R_{i-1}`\$ as the salt and `"SURETY_RATCHET"` as the info.

```math
\begin{aligned}
    R_i\;\parallel\;C_{i,0}&=HKDF\left(
        R_{i-1},\,
        ECDH\left(T_{i-1},\,T_i\right),\,
        \text{"SURETY\_RATCHET"},\,
        64
    \right)
\end{aligned}
```

### Advancing the chain key

Advancing a chain key takes the previous chain key, \$`C_{i,j-1}`$. The next
chain key, $`C_{i,j}`\$, is the [HMAC-SHA-256][] of `"\x02"` using the previous chain key as the key.

```math
\begin{aligned}
    C_{i,j}&=HMAC\left(C_{i,j-1},\,\text{"\x02"}\right)
\end{aligned}
```

### Creating a message key

Creating a message key takes the current chain key, \$`C_{i,j}`$. The
message key, $`M_{i,j}`\$, is the [HMAC-SHA-256][] of `"\x01"` using the current chain key as the key. The message keys where \$`i`$ is even are used
by Dochughes to encrypt messages. The message keys where $`i`\$ is odd are used by Whimzzy to encrypt messages.

```math
\begin{aligned}
    M_{i,j}&=HMAC\left(C_{i,j},\,\text{"\x01"}\right)
\end{aligned}
```

### Creating an outbound session

Whimzzy publishes the public parts of his identity key, \$`I_B`$, and some
single-use one-time keys $`E_B`\$.

Dochughes downloads Whimzzy's identity key, \$`I_B`$, and a one-time key,
$`E_B`$. He  generates a new single-use key, $`E_A`$, and computes a
root key, $`R_0`$, and a chain key $`C_{0,0}`$. He  also generates a
new ratchet key $`T_0`\$.

### Sending the first pre-key messages

Dochughes computes a message key, \$`M_{0,j}`$, and a new chain key,
$`C_{0,j+1}`\$, using the current chain key. He replaces the current chain key with the new one.

Dochughes encrypts his plain-text with the message key, \$`M_{0,j}`$, using an
authenticated encryption scheme (see below) to get a cipher-text,
$`X_{0,j}`\$.

He then sends the following to Whimzyy:

- The public part of his identity key, $`I_A`$
- The public part of his single-use key, $`E_A`$
- The public part of Whimzzy's single-use key, $`E_B`$
- The current chain index, $`j`$
- The public part of his ratchet key, $`T_0`$
- The cipher-text, $`X_{0,j}`$

Dochughes will continue to send pre-key messages until he receives a message from Whimzzy.

### Creating an inbound session from a pre-key message

Whimzzy receives a pre-key message as above.

Whimzzy looks up the private part of his single-use key, \$`E_B`$. He can now
compute the root key, $`R_0`$, and the chain key, $`C_{0,0}`$, from
$`I_A`$, $`E_A`$, $`I_B`$, and $`E_B`\$.

Whimzzy then advances the chain key \$`j`$ times, to compute the chain key used
by the message, $`C_{0,j}`$. He now creates the
message key, $`M_{0,j}`$, and attempts to decrypt the cipher-text,
$`X_{0,j}`$. If the cipher-text's authentication is correct then Whimzzy can
discard the private part of his single-use one-time key, $`E_B`\$.

Whimzzy stores Dochughes's initial ratchet key, $`T_0`$, until he wants to send a message.

### Sending normal messages

Once a message has been received from the other side, a session is considered established, and a more compact form is used.

To send a message, the user checks if they have a sender chain key, \$`C_{i,j}`$. Dochughes uses chain keys where $`i`$ is even. Whimzzy uses chain
keys where $`i`$ is odd. If the chain key doesn't exist then a new ratchet
key $`T_i`$ is generated and a new root key $`R_i`$ and chain key
$`C_{i,0}`$ are computed using $`R_{i-1}`$, $`T_{i-1}`$ and
$`T_i`\$.

A message key, \$`M_{i,j}`$ is computed from the current chain key, $`C_{i,j}`$, and
the chain key is replaced with the next chain key, $`C_{i,j+1}`$. The
plain-text is encrypted with $`M_{i,j}`$, using an authenticated encryption
scheme (see below) to get a cipher-text, $`X_{i,j}`\$.

The user then sends the following to the recipient:

- The current chain index, $`j`$
- The public part of the current ratchet key, $`T_i`$
- The cipher-text, $`X_{i,j}`$

### Receiving messages

The user receives a message as above with the sender's current chain index, \$`j`$,
the sender's ratchet key, $`T_i`$, and the cipher-text, $`X_{i,j}`\$.

The user checks if they have a receiver chain with the correct \$`i`$ by comparing the ratchet key, $`T_i`$. If the chain doesn't exist
then they compute a new root key, $`R_i`$, and a new receiver chain, with
chain key $`C_{i,0}`$, using $`R_{i-1}`$, $`T_{i-1}`$ and
$`T_i`\$.

If the \$`j`$ of the message is less than
the current chain index on the receiver then the message may only be decrypted
if the receiver has stored a copy of the message key $`M_{i,j}`$. Otherwise
the receiver computes the chain key, $`C_{i,j}`$. The receiver computes the
message key, $`M_{i,j}`$, from the chain key and attempts to decrypt the
cipher-text, $`X_{i,j}`\$.

If the decryption succeeds the receiver updates the chain key for \$`T_i`$
with $`C_{i,j+1}`\$ and stores the message keys that were skipped in the process so that they can decode out of order messages. If the receiver created a new receiver chain then they discard their current sender chain so that they will create a new chain when they next send a message.

### Surety Message Format

Surety uses two types of messages. The underlying transport protocol must provide a means for recipients to distinguish between them.

#### Normal Messages

Surety messages start with a one byte version followed by a variable length payload followed by a fixed length message authentication code.

```
 +--------------+------------------------------------+-----------+
 | Version Byte | Payload Bytes                      | MAC Bytes |
 +--------------+------------------------------------+-----------+
```

The version byte is `"\x03"`.

The payload consists of key-value pairs where the keys are integers and the values are integers and strings. The keys are encoded as a variable length integer tag where the 3 lowest bits indicates the type of the value: 0 for integers, 2 for strings. If the value is an integer then the tag is followed by the value encoded as a variable length integer. If the value is a string then the tag is followed by the length of the string encoded as a variable length integer followed by the string itself.

Surety uses a variable length encoding for integers. Each integer is encoded as a sequence of bytes with the high bit set followed by a byte with the high bit clear. The seven low bits of each byte store the bits of the integer. The least significant bits are stored in the first byte.

|  **Name**   | **Tag** | **Type** |                      **Meaning**                       |
| :---------: | :-----: | :------: | :----------------------------------------------------: |
| Ratchet-Key |  0x0A   |  String  | The public part of the ratchet key, Ti, of the message |
| Chain-Index |  0x10   | Integer  |           The chain index, j, of the message           |
| Cipher-Text |  0x22   |  String  |     The cipher-text, Xi,Ã¢â‚¬â€¦j, of the message      |

The length of the MAC is determined by the authenticated encryption algorithm being used. (Surety version 1 uses [HMAC-SHA-256][], truncated to 8 bytes). The MAC protects all of the bytes preceding the MAC.

#### Pre-Key Messages

Surety pre-key messages start with a one byte version followed by a variable length payload.

```
 +--------------+------------------------------------+
 | Version Byte | Payload Bytes                      |
 +--------------+------------------------------------+
```

The version byte is `"\x03"`.

The payload uses the same key-value format as for normal messages.

|   **Name**   | **Tag** | **Type** |                       **Meaning**                        |
| :----------: | :-----: | :------: | :------------------------------------------------------: |
| One-Time-Key |  0x0A   |  String  |     The public part of Whimzzy's single-use key, Eb.     |
|   Base-Key   |  0x12   |  String  |    The public part of Dochughes's single-use key, Ea.    |
| Identity-Key |  0x1A   |  String  |     The public part of Dochughes's identity key, Ia.     |
|   Message    |  0x22   |  String  | An embedded Surety message with its own version and MAC. |

## Authentication Encryption

Concerns about authentication encyrption in the Olm Ratchet of the Matrix Procol led to the creation of the Durable Identity Protocol. Surety is the implentation of these issues being addressed scoping the two users already confirmed outside key-pairs to confirm the recipients. Below you'll find the initial implementation of the ratchet and examples that the Durable Identity Protcol addresses.

### Original Method

We initially liked the usage of [AES-256][] in [CBC][] mode with [PKCS##7][] padding for encryption and [HMAC-SHA-256][] (truncated to 64 bits) for authentication when Dura was DuraChain. The 256 bit AES key, 256 bit HMAC key, and 128 bit AES IV are derived from the message key using [HKDF-SHA-256][] using the default salt and an info of `"SURETY_KEYS"`.

```math
\begin{aligned}
    AES\_KEY_{i,j}\;\parallel\;HMAC\_KEY_{i,j}\;\parallel\;AES\_IV_{i,j}
    &= HKDF\left(0,\,M_{i,j},\text{"SURETY\_KEYS"},\,80\right) \\
\end{aligned}
```

The plain-text is encrypted with AES-256, using the key \$`AES\_KEY_{i,j}`$
and the IV $`AES\_IV_{i,j}`$ to give the cipher-text, $`X_{i,j}`\$.

### Incorrect Key Ownership Confirmation

Thee entire message (including the Version Byte and all Payload Bytes) are passed through [HMAC-SHA-256][]. The first 8 bytes of the MAC are appended to the message.

To elaborate more, in-order for an application to avoid unknown key-share attacks, it must include identifying data for the sending and receiving user in the plain-text. Most importantly the pre-key messages. This includes things such as a user's ID, telephone number, or, alternatively, the identifying issue could be public part of a keypair which the relevant user has proven ownership of perviously. The resulting attacks are comparable to double-spending attacks on a blockchain. Let's look at some examples of misguided identitification:

#### Examples

1. _race-attack_ Dochughes publishes his public [Curve25519][] identity key, \$`I_A`$. xcesiv publishes the same identity key, claiming it as his own. Whimzzy downloads xcesiv's keys, and associates $`I_A`\$ with xcesiv. Dochughes sends a message to Whimzyy; xcesiv intercepts it before forwarding it to Whimzyy. Whimzzy now believes the message came from xcesiv rather than Dochughes.

This is prevented if Dochughes includes his user ID in the plain-text of the pre-key message. This way Wimzzy can see that the message was sent by Dochughes originally.

2. _alternative-history-attack_ Whimzzy publishes his public [Curve25519][] identity key, \$`I_B`$. xcesiv publishes the same identity key, claiming it as his own. Dochughes downloads xcesiv's keys, and associates $`I_B`\$ with xcesiv. Dochughes sends a message to xcesiv; xcesiv cannot decrypt it, but forwards it to Whimzyy. Whimzzy believes the Dochughes sent the message to him, wheras Dochughes intended it to go to xcesiv.

This is prevented by Dochughes including the user ID of the intended recpient (xcesiv) in the plain-text of the pre-key message. Whimzzy can now tell that the message was meant for xcesiv rather than him.
